# A2. Кубическое пробирование

Хеш-таблицы с ***открытой адресацией*** используют различные методы пробирования для разрешения коллизий, к основным из которых можно отнести:

1. ***Линейное*** пробирование, при котором последовательно проверяются ячейки хеш-таблицы с индексами ℎ𝑎𝑠ℎ(𝑘𝑒𝑦),ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+1,ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+2,...
2. ***Квадратичное*** пробирование ℎ𝑎𝑠ℎ(𝑘𝑒𝑦,𝑖)=ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+$𝑐_1$⋅𝑖+$𝑐_2$⋅$𝑖^2$
, при котором:

    * в простом варианте при 𝑐1=𝑐2=1
 последовательно проверяются ячейки:
 
            ℎ𝑎𝑠ℎ(𝑘𝑒𝑦),ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+1, ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+2, ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+6 ...
    * для хеш-таблицы размера 𝑀=$2^𝑚$
 при 𝑐1=𝑐2=$\frac12$
 последовательно проверяются ячейки:
 
            ℎ𝑎𝑠ℎ(𝑘𝑒𝑦),ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+1, ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+3, ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+6 ...

Мы решили пойти дальше и рассмотреть ***кубическое*** пробирование, при котором проверка ячеек в хеш-таблице выполняются по следующему правилу: ℎ𝑎𝑠ℎ(𝑘𝑒𝑦,𝑖)=ℎ𝑎𝑠ℎ(𝑘𝑒𝑦)+𝑐1⋅𝑖+𝑐2⋅𝑖2+𝑐3⋅𝑖3
. 

Оцените, будет ли кубическое пробирование выполнять распределение ключей по хеш-таблице лучше (более равномерно), чем квадратичное, с точки зрения образования кластеров и возникновения коллизий. Подкрепите свои рассуждения ***программными экспериментами*** с хеш-таблицами различных размеров, а также приложите код. Ограничений на используемые языки программирования в этом задании нет.

## Предварительный анализ

Фундаментальная задача пробирования - создать равномерное распределение по всей таблице, т. е. не допустить создания слишком больших кластеров и использовать все ячейки таблицы.

функция нашего кубического пробирования будет иметь вид:

$hashcub(key, i) = hash(key) + ic_1 + i^2c_2 + i^3c_3 $

```python
p = 16 # меняемый размер массива
m = [0 for _ in range(p)]
for c1 in range(5):
    for c2 in range(5):
        for c3 in range(5):
            m = [0 for _ in range(p)]
            for i in range(100): # менять кол-во вставок в зависимости от p
                if((c1*i + c2*i*i + c3*i**3)%1!=0):
                    break
                m[(c1*i + c2*i*i + c3*i**3)%p] += 1
            if(all(x!=0 for x in m) and c3!=0):
                print(m,c1, c2, c3)
```

был написан такой скрипт для нахождения хороших коэффициентов. В начале для размера массива пробовал использовать простые числа, но для них закономерностей не нашлось. Потом решил попробовать посмотреть как в квадратичном плобировании степени двойки в качестве длин массивов, и это оказалось хорошей стратегией.

Появились коэффициенты которые выдавали достаточно равномерно распределенное распространение на каждой длине (среди степеней двоек)

они оказались такими
```
c1  c2  c3
----------
1   0   2
1   0   4
1   2   2
1   2   4
1   4   2
1   4   4
3   0   2
3   0   4
3   2   2
3   2   4
3   4   2
3   4   4
```
для удобства будем использовать первую тройку. Теперь наша функция имеет вид

$hashcub(key, i) = hash(key) + i + 2i^3 $

После был написан такой код для сравнения видов пробирования

```cpp
#include <iostream>
#include <vector>

std::hash<int> hasher{};

size_t hash1(int a, size_t i){
    return hasher(a) + i/2 + i*i/2;
}

size_t hash2(int a, size_t i){
    return hasher(a) + i + 2*i*i*i;
}

inline void coutvec(std::vector<int> &v){
    for(size_t i = 0; i < v.size(); ++i){
        std::cout<<v[i]<<' ';
    }
    std::cout<<'\n';
}

int main(){
    size_t M = 256;
    std::vector<int> v1(M, 0);
    std::vector<int> v2(M, 0);

    for(size_t i = 0; i < 100; ++i){
        v1[hash1(1, i) % M] += 1;
        v2[hash2(1, i) % M] += 1;
        std::cout<<"quadro:\n";
        coutvec(v1);
        std::cout<<"cubo:\n";
        coutvec(v1);
    } 
    return 0;
}
```

который показал, что на самом деле оба хеша идентичны:

```
...
quadro:
1 2 0 0 2 0 1 0 0 0 1 2 1 0 0 1 0 1 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 1 0 2 1 0 0 2 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 1 0 0 2 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 2 0 0 0 0 1 0 1 0 0 0 0 2 0 0 1 0 0 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 2 0 2 0 1 0 0 2 0 0 0 1 0 1 1 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 2 1 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 2 0 1 0 
cubo:
1 2 0 0 2 0 1 0 0 0 1 2 1 0 0 1 0 1 0 1 1 0 1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1 0 1 0 0 0 1 0 2 1 0 0 2 0 0 0 1 0 0 1 0 1 0 0 1 0 0 0 0 1 0 0 2 0 1 0 0 0 0 1 1 0 1 0 0 0 0 1 0 1 0 1 0 1 1 0 1 0 0 1 1 0 2 0 0 0 0 1 0 1 0 0 0 0 2 0 0 1 0 0 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 0 0 0 2 0 2 0 1 0 0 2 0 0 0 1 0 1 1 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 0 1 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1 0 1 1 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 2 1 0 0 1 0 0 0 0 0 1 0 0 1 2 0 0 0 0 1 0 0 2 0 1 0 
```