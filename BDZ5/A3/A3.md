# А3b. Взломщик!

Для хеширования строковых ключей, которые могут содержать строчные/прописные латинские буквы и цифры, используется следующая полиномиальная хеш-функция, значение которой определяется числовым параметром p:

![alt text](../assets/a3.png)

Для того, чтобы взломать хеш-функцию, требуется найти такой набор строк, который вызывает коллизии — одинаковые значения хеш-функции.

* (7 баллов) Одним из способов подбора строк, вызывающих коллизии, является поиск так называемых нейтральных элементов — строк, значение хеш-функции которых обращается в 0. Разработайте и обоснуйте алгоритм поиска строк, состоящих из двух символов, которые будут являться нейтральными элементами. Представьте обоснование и реализацию алгоритма. Ограничений на используемые языки программирования в этом задании нет.
* (3 балла) Найдите нейтральные элементы для всех значений параметра p ≤ 31.

## 1.

Будем считать что ***р*** натуральное число (иначе ограничение во втором пункте выглядело бы слишком страшным)

Для решения этой задачи нам понадобится таблица ascii

![alt text](../assets/ascii.png)

теперь мы можем понять что

```cpp
(s[i] - 'a' + 1)
```

можно описать более удобно:

* если ***s[i]*** строчная буква, то это выражение будет равно ее номеру, начиная с единицы

* если ***s[i]*** прописная буква, то выражение будет равно ее номеру минус 32

* если же ***s[i]*** цифра, то выражение будет равно ей минус 67

тогда хеш-функция будет зануляться только если один из ее символов сточная буква, а другой либо прописная либо цифра, причем строчная всегда вторая.

***в задании сказано найти алгоритм поиска всех строк из двух элементов подходящих под условие, и не сказано что это не должно быть брутфорсом, тем более в данном случае он работает за О(1) и вычисляет быстро. Тем не менее скорее всего авторы ожидают более элегантное решение, поэтому найду его***


Вот такую функцию я написал:

Полный файл можно увидеть по ссылке:
[A3.cpp](https://github.com/Babushkin05/HSE_SE_ALGO/blob/main/BDZ5/A3/A3.cpp)

```cpp
std::vector<std::string> allnulls(int p){
    if(std::abs(p) < 2)
        return std::vector<std::string>();
    std::vector<std::string> ans;

    for(char i = '0'; i <= '9'; ++i){
        if(-26 * p <= (i - 'a' + 1) && (i - 'a' + 1) <= -1 * p && (i - 'a' + 1) % p == 0){
            std::string s;
            s+=i;
            s+='a' - (i - 'a' + 1)/p - 1;
            ans.push_back(s);
        }
    }
    for(char i = 'A'; i <= 'Z'; ++i){
        if(-26 * p <= (i - 'a' + 1) && (i - 'a' + 1) <= -1 * p && (i - 'a' + 1) % p == 0){
            std::string s;
            s+=i;
            s+='a' - (i - 'a' + 1)/p - 1;
            ans.push_back(s);
        }
    }

    return ans;
}
```

В отличии от бруфорса перебирает только первый символ

В ней я перебираю первый символ и проверяю существует ли подходящий второй. Вся арифметика взята из равенства 

```cpp
(s[0] - 'a' + 1) = (s[1] - 'a' + 1) * p;
```

Например для ***p = 5*** она дает результат

```
0x 2w 4v 6u 8t Bo Dn Fm Hl Jk Lj Ni Ph Rg Tf Ve Xd Zc 
```
Проверим - действительно подходит.

## Найдем все такие для каждого ***p***

Напишем вот такой код

[A3.cpp](https://github.com/Babushkin05/HSE_SE_ALGO/blob/main/BDZ5/A3/A3.cpp)

```cpp
#include <iostream>
#include <vector>
#include <string>

std::vector<std::string> allnulls(int p){
    if(std::abs(p) < 2)
        return std::vector<std::string>();
    std::vector<std::string> ans;

    for(char i = '0'; i <= '9'; ++i){
        if(-26 * p <= (i - 'a' + 1) && (i - 'a' + 1) <= -1 * p && (i - 'a' + 1) % p == 0){
            std::string s;
            s+=i;
            s+='a' - (i - 'a' + 1)/p - 1;
            ans.push_back(s);
        }
    }
    for(char i = 'A'; i <= 'Z'; ++i){
        if(-26 * p <= (i - 'a' + 1) && (i - 'a' + 1) <= -1 * p && (i - 'a' + 1) % p == 0){
            std::string s;
            s+=i;
            s+='a' - (i - 'a' + 1)/p - 1;
            ans.push_back(s);
        }
    }

    return ans;
}

void coutvec(std::vector<std::string> &v){
    for(auto s : v){
        std::cout<<s<<' ';
    }
    std::cout<<'\n';
}

int main(){
    for(size_t p = 0; p <= 31; ++p){
        std::cout<<p<<" : ";
        std::vector<std::string> v = allnulls(p);
        coutvec(v);
    }
    return 0;
}
````

И получим вот такой вывод:

```
0 : 
1 : 
2 : 0x 2w 4v 6u 8t Bo Dn Fm Hl Jk Lj Ni Ph Rg Tf Ve Xd Zc 
3 : 0p 3o 6n 9m Bj Ei Hh Kg Nf Qe Td Wc Zb 
4 : 0l 4k 8j Dg Hf Le Pd Tc Xb 
5 : 3i 8h Bf Ge Ld Qc Vb 
6 : 0h 6g Be Hd Nc Tb Za 
7 : 6f Dd Kc Rb Ya 
8 : 0f 8e Hc Pb Xa 
9 : 3e Ec Nb Wa 
10 : 8d Bc Lb Va 
11 : 4d Jb Ua 
12 : 0d Hb Ta 
13 : 9c Fb Sa 
14 : 6c Db Ra 
15 : 3c Bb Qa 
16 : 0c Pa 
17 : Oa 
18 : Na 
19 : Ma 
20 : 8b La 
21 : 6b Ka 
22 : 4b Ja 
23 : 2b Ia 
24 : 0b Ha 
25 : Ga 
26 : Fa 
27 : Ea 
28 : Da 
29 : Ca 
30 : Ba 
31 : Aa 
```