# A4 Разные алгоритмы решения одной* задачи

![alt text](image.png)

## 1. Утверждается, что представленные алгоритмы должны решать одну и ту же задачу, т. е., выдавать один и тот же ответ на одинаковых входных данных.

### Согласны ли вы с этим утверждением? Результаты работы каких алгоритмов из представленных могут отличаться? Какую задачу решает каждый алгоритм?

давайте вначале напишем какую задачу решает каждый алгоритм

-----
#### алгоритм1:

возвращает индекс элемента, которого в массиве больше половины

#### алгоритм2:

возвращает самую длинный интервал начало которого совпадает с началом массива, такой чтобы его можно было поделить на отрезки в каждом из которых половина элементов одинаковое


#### алгоритм3:

решает ту же задачу, что и 1 алгоритм, только он ничего не вернет если этот повторяющийся элемент будет максимумом

-----
Поэтому я не согласен, что эти алгоритмы решают одну задачу. Совершенно отличается 2й алгоритм, и 1й с 3и немного


### Приведите примеры входных данных, при которых результаты работы алгоритмов могут отличаться, а также совпадать. Поясните свой ответ с помощью трассировки (частичной) работы алгоритмов.

вначале приведу пример когда результаты совпадают

это случай такого массива

```python
[1,2,1,2,1,2,1]
```

во всех алгоритмах вернет $1$

давайте рассмотрим трассировку в каждом:

трассировка 1 алгоритма


| **i** | **c1** | **c** | **ind** |
|:-----:|:------:|:-----:|:-------:|
| 0     | 4      | 4     | 0       |
| 1     | 3      | 4     | 0       |
| 2     | 4      | 4     | 2       |
| ...   | ...    | ...   | ...     |
| 6     | 4      | 4     | 6       |

алгоритм вернет ```A[6]``` то есть 1

трассировка 2 алгоритма:

| **i** | **с** | **ind** |
|:-----:|:-----:|:-------:|
| 1     | 0     | 1       |
| 2     | 0     | 2       |
| ...   | ...   | ...     |
| 6     | 0     | 6       |

алгоритм тоже вернет элемент ```A[6]```

трассировка 3 алгоритма:

| **i** | **с** |
|:-----:|:-----:|
| 1     | 2     |
| 2     | 3     |
| 3     | 4     |


а этот алгоритм вернет ```A[3]``` отсортированного массива, которое совпадает с изначальным ```A[6]```

#### приведем пример в котором ответы не будут совпадать:

```python
[1,2,1,2,1,2,1]
```

давайте рассмотрим трассировку в каждом:

трассировка 1 алгоритма


| **i** | **c1** | **c** | **ind** |
|:-----:|:------:|:-----:|:-------:|
| 0     | 4      | 4     | 0       |
| 1     | 3      | 4     | 0       |
| 2     | 4      | 4     | 2       |
| ...   | ...    | ...   | ...     |
| 6     | 4      | 4     | 6       |

алгоритм вернет ```A[6]``` то есть 1

трассировка 2 алгоритма:

| **i** | **с** | **ind** |
|:-----:|:-----:|:-------:|
| 1     | 0     | 1       |
| 2     | 0     | 2       |
| ...   | ...   | ...     |
| 6     | 0     | 6       |

алгоритм тоже вернет элемент ```A[6]```

трассировка 3 алгоритма:

| **i** | **с** |
|:-----:|:-----:|
| 1     | 2     |
| 2     | 3     |
| 3     | 1     |
| ...   | ...   |
| 6     | 4     |

а этот алгоритм ничего не вернет

## 2. Вычислите асимптотическую верхнюю границу $O(f(n))$ временной сложности для каждого алгоритма. Обоснуйте свой ответ. Представлять полный расчет точного выражения функции временной сложности $T(n)$ не нужно.