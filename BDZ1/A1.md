<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      processEscapes: true},
      jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"],
      extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"],
      TeX: {
      extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"],
      equationNumbers: {
      autoNumber: "AMS"
      }
    }
  });
</script>

# A1

![alt text](assets/image.png)

## 1. Сформулируйте условие $P1$ , которое подходит в качестве инварианта внутреннего цикла алгоритма по $j$. Представьте краткое обоснование (например, с использованием частичной трассировки выполнения цикла).

$P1$ : $A[minId] = min(A[(i+1)..j])$

докажем с метода мат.индукции

во время захода в цикл условие выполняется, потому что это минимум из одного элемента

ШАГ.

Пусть условие выполняется для $j$, докажем что выполняется для $j+1$

Если $A[j+1]<A[minId]$ тогда $minId = j+1$ условие продолжает выполнятся

В обратном случае условие тем более продолжает выполнятся

ч.т.д.

## 2. (Сформулируйте условие $P2$, которое подходит в качестве инварианта внешнего цикла алгоритма по $i$. Представьте краткое обоснование.


$P2:$ в конце итерации  $A[..i] = sorted(A)[..i]$

докажем методом мат.индукции

БАЗА:

Первый цикл по $j$ найдет наименьший элемент массива, тем самым условие будет выполнятся

ШАГ:

пусть условие выполняется для $i$, докажем для $i+1$

внутренний цикл найдет наименьший элемент среди $A[i+1..]$ 

свопом мы поставим его на место $i+1$ тем самым инвариант продолжит выполнятся

## 3. Выполните проверку выполнения найденных инвариантов P1 и P2 до входа в каждый из циклов (INIT), во время итерации циклов (MNT), при выходе из цикла (TRM).

### INIT

#### P1

когда мы входим в цикл, j = i+1

тогда в интервале $A[i..(i+1)]$ будет находится 2 элемента, мы их сравниваем и выбираем меньший. инвариант выполняется

#### P2

в цикле по $j$ находим индекс минимального элемента, и этот элемент как раз и будет $sorted(A)[0]$ инвариант выполняется.

### MNT

#### P1

у нас уже есть индекс минимального элемента среди $A[i..j]$

мы сравниваем этот элемент с $A[j+1]$ и по необходимости меняем minInd,
таким образом инвариант выполняется.

#### P2

$A[..i]$ уже отсортированны как надо

находим минимальный элемент среди $A[(i+1)..]$ с помощью цикла по $j$, и ставим его на место $A[i+1]$ инвариант продолжает выполнятся

### TRM

#### P1

с помощью этого цикла мы находим индекс минимального элемента среди $A[i+1..]$

тогда при $j=n-1$ получается что мы нашли минимум на интервале $A[i+1..n-1]$, значит инвариант и здесь выполняется

#### P2

в конце этого цикла наш массив отсортирован по неубыванию

тогда $A = sorted(A)$ инвариант выполняется!!